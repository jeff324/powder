% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sampling.R
\name{powder}
\alias{powder}
\title{Power posterior sampling using differential evolution}
\usage{
powder(data, model, num.temps = NULL, alpha = 0.3,
  high.temps.first = FALSE, n.sequences = NULL, current.sequence = NULL,
  n.samples = 1000, n.chains = NULL, burnin = 500, meltin = 250,
  de_params = list(b = 0.001, migration = FALSE, migration.freq = NULL,
  migration.start = NULL, migration.end = NULL), n.subj = NULL,
  n.pars = NULL, n.hpars = NULL, sample.posterior = FALSE,
  return.samples = TRUE)
}
\arguments{
\item{data}{A list of data where each element is the data for a specific subject}

\item{model}{See \code{\link{LBA}} for more information and an example.}

\item{num.temps}{Number of temperatures (i.e. number of power posteriors to sample from)}

\item{alpha}{controls the temperature schedule. 0.3 is recommended.}

\item{high.temps.first}{If true, then the posterior will be sampled from first, followed by lower temperature posteriors.
If false, then the prior will be sampled from first, followed by higher temperature posteriors.}

\item{n.sequences}{This is useful for running parallel power posteriors. If \code{n.sequences = 1}, then all power posteriors
will be run sequentially. If \code{n.sequences > 1} then \code{num.temps / n.sequences}
power posteriors will be run sequentially.}

\item{current.sequence}{If n.sequences > 1, then \code{num.temps / n.sequences} power posteriors will be run sequentially.
\code{current.sequence} is the index of the current sequence. For example, if \code{num.temps = 10}, \code{n.sequences = 2}, and
\code{current.sequence = 1} then temperatures 1 through 5 will be run.
If \code{current.sequence = 2} then temperatures 6 through 10 will be run.}

\item{n.samples}{The number of samples to draw from each power posterior}

\item{n.chains}{The number of chains to use. By default, \code{n.chains} is the number of subject-level parameters times 3.}

\item{burnin}{The number of samples to discard when computing the marginal likelihood.
These samples are included in the raw output.}

\item{meltin}{The power posteriors are sampled sequentially. When moving to the next power posterior, the sampling process
takes some time to adapt to the new power posterior. \code{meltin} is the number of samples to discard after moving to the next
power posterior. While \code{burnin} discards samples from the first power posterior, \code{meltin} discard samples for all
other power posteriors.}

\item{de_params}{A list containing the following options for DE-MCMC. See Turner et al. (2013) for details.
\itemize{
\item \code{b} The parameter for the uniformly distributed noise term for the DE proposal. Default is .001.
\item \code{migration} Circulates the states of the chains to remedy problem of outlier chains.
\item \code{migration.freq} Number of iterations to wait between each migration step
\item \code{migration.start} When to start migrating. This should be after chains are burned in.
\item \code{migration.end} When to stop migrating. Migration should stop well before sampling is finished.
}}

\item{n.subj}{The number of elements in \code{data}. Defaults to \code{length(data)}.}

\item{n.pars}{The number of subject-level parameters}

\item{n.hpars}{The number of group-level parameters}

\item{sample.posterior}{If true, only the posterior will be sampled. This causes other arguments, like num.temps to be ignored.}

\item{return.samples}{If true, return subject and group-level samples.
Otherwise, return only the log likelihoods from each power posterior.}
}
\value{
A list with the following elements.

\code{log.like.list} A list containing the log likelihoods for each temperature

\code{theta} An array containing the subject-level samples

\code{phi} An array containing the group-level samples

Note, if \code{return.samples = FALSE} then only \code{log.like.list} will be returned.
}
\description{
\code{powder} Runs power posterior sampling using differential evolution markov chain monte carlo
}
\examples{
\dontrun{
model = LBA$new(b=T)
data('null',package='powder')
num.temps = 30
pow.out = powder(data=null, model=model, num.temps=num.temps)
est = marginal_likelihood(pow.out)
print(est)
}
}
